# Yoyoo 技术学习笔记：多租户数据库架构

> **学习日期**: 2026-01-31
> **目标**: 掌握多租户数据库设计模式，为 Yoyoo 平台设计合理的数据库架构

---

## 1. 多租户架构模式

### 1.1 三种主要模式

| 模式 | 说明 | 优点 | 缺点 | 适用场景 |
|------|------|------|------|----------|
| **独立数据库** | 每个租户一个数据库 | 隔离性最强、数据备份简单 | 成本高、管理复杂 | 高安全要求、大企业客户 |
| **共享数据库+独立 Schema** | 每个租户一个 Schema | 中等隔离、备份方便 | 迁移复杂 | 中等规模应用 |
| **共享数据库+共享 Schema** | 所有租户数据同表 | 成本最低、维护简单 | 隔离性最弱、SQL 复杂 | 小规模、低成本应用 |

### 1.2 Yoyoo 选择：共享数据库 + 共享 Schema + tenant_id

**选择理由**：
- 成本考虑（不需要大量数据库实例）
- 管理简单（单数据库运维）
- 足够隔离（通过 tenant_id 过滤）
- 易于扩展（增加字段而非增加实例）

```
┌─────────────────────────────────────────────────────────────┐
│                    PostgreSQL                               │
│  ┌─────────────────────────────────────────────────┐    │
│  │              Yoyoo Database                      │    │
│  │  ┌─────────────────────────────────────────┐  │    │
│  │  │           users 表                      │  │    │
│  │  │  ┌─────────┬─────────┬─────────┐     │  │    │
│  │  │  │ tenant1 │ tenant2 │ tenant3 │ ... │  │    │
│  │  │  └─────────┴─────────┴─────────┘     │  │    │
│  │  └─────────────────────────────────────────┘  │    │
│  │  ┌─────────────────────────────────────────┐  │    │
│  │  │           yooos 表                     │  │    │
│  │  │  ┌─────────┬─────────┬─────────┐     │  │    │
│  │  │  │ tenant1 │ tenant2 │ tenant3 │ ... │  │    │
│  │  │  └─────────┴─────────┴─────────┘     │  │    │
│  │  └─────────────────────────────────────────┘  │    │
│  └─────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. 数据库设计原则

### 2.1 核心原则

| 原则 | 说明 |
|------|------|
| **tenant_id 必选** | 所有业务表必须有 tenant_id 字段 |
| **索引优化** | tenant_id 必须是索引前缀 |
| **软删除** | 使用 is_deleted 字段而非物理删除 |
| **审计字段** | created_at, updated_at, created_by |
| **幂等性** | 操作支持重入，idempotency_key |

### 2.2 命名规范

| 类型 | 前缀 | 示例 |
|------|------|------|
| 主键 | pk_ | pk_users |
| 外键 | fk_ | fk_users_tenant_id |
| 唯一索引 | uk_ | uk_users_email_tenant_id |
| 普通索引 | idx_ | idx_yooos_tenant_id_status |

---

## 3. Yoyoo 核心表设计

### 3.1 ER 图

```
┌─────────────┐       ┌─────────────┐       ┌─────────────┐
│  tenants   │       │   users    │       │  yooos    │
├─────────────┤       ├─────────────┤       ├─────────────┤
│ pk_id      │◄──────│ fk_tenant_id      │       │ fk_user_id │
│ name       │       │ pk_id      │◄──────│ pk_id      │
│ plan       │       │ email      │       │ name       │
│ created_at │       │ name       │       │ config     │
│ updated_at │       │ password   │       │ status     │
└─────────────┘       │ role       │       │ created_at │
        ▲            │ created_at │       └──────┬──────┘
        │            └─────────────┘              │
        │                   ▲                   │
        │                   │                   │
┌─────────────┐    ┌──────┴──────┐    ┌─────────────┐
│  sessions   │    │  tasks     │    │ skills     │
├─────────────┤    ├─────────────┤    ├─────────────┤
│ fk_user_id │    │ fk_yoo_id  │    │ fk_yoo_id  │
│ fk_tenant_id│    │ pk_id      │    │ pk_id      │
│ pk_id      │    │ title      │    │ name       │
│ token      │    │ status     │    │ config     │
│ expires_at │    │ created_at │    │ created_at │
└─────────────┘    └─────────────┘    └─────────────┘
```

### 3.2 表结构定义

#### 3.2.1 tenants (租户表)

```sql
-- 租户表
CREATE TABLE tenants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(100) UNIQUE NOT NULL,
    plan VARCHAR(50) DEFAULT 'free' CHECK (plan IN ('free', 'pro', 'enterprise')),
    settings JSONB DEFAULT '{}',
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 索引
CREATE INDEX idx_tenants_slug ON tenants(slug);
CREATE INDEX idx_tenants_is_active ON tenants(is_active);

-- 更新时间触发器
CREATE TRIGGER update_tenants_updated_at
    BEFORE UPDATE ON tenants
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

#### 3.2.2 users (用户表)

```sql
-- 用户表
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    email VARCHAR(255) NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    name VARCHAR(255) NOT NULL,
    avatar_url TEXT,
    role VARCHAR(50) DEFAULT 'member' CHECK (role IN ('owner', 'admin', 'member')),
    is_active BOOLEAN DEFAULT TRUE,
    email_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    -- 唯一约束 (email + tenant_id)
    CONSTRAINT uk_users_email_tenant UNIQUE (email, tenant_id)
);

-- 索引
CREATE INDEX idx_users_tenant_id ON users(tenant_id);
CREATE INDEX idx_users_email ON users(email) WHERE is_active = TRUE;
CREATE INDEX idx_users_role ON users(tenant_id, role);

-- 外键约束
ALTER TABLE users
    ADD CONSTRAINT fk_users_tenant
    FOREIGN KEY (tenant_id) REFERENCES tenants(id);
```

#### 3.2.3 yooos (Yooos 实例表)

```sql
-- Yooos 实例表
CREATE TABLE yooos (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    config JSONB DEFAULT '{}',
    status VARCHAR(50) DEFAULT 'stopped' CHECK (status IN ('stopped', 'starting', 'running', 'stopping', 'error')),
    current_model VARCHAR(100),
    memory_usage BIGINT DEFAULT 0,
    last_heartbeat_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    -- 每个用户可以有多个 Yooos
    CONSTRAINT uk_yooos_user_name UNIQUE (user_id, name)
);

-- 索引
CREATE INDEX idx_yooos_tenant_id ON yooos(tenant_id);
CREATE INDEX idx_yooos_user_id ON yooos(user_id);
CREATE INDEX idx_yooos_status ON yooos(tenant_id, status);
CREATE INDEX idx_yooos_last_heartbeat ON yooos(last_heartbeat_at);

-- 外键约束
ALTER TABLE yooos
    ADD CONSTRAINT fk_yooos_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id);
ALTER TABLE yooos
    ADD CONSTRAINT fk_yooos_user FOREIGN KEY (user_id) REFERENCES users(id);
```

#### 3.2.4 tasks (任务表)

```sql
-- 任务表
CREATE TABLE tasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    yoo_id UUID NOT NULL REFERENCES yooos(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(500) NOT NULL,
    description TEXT,
    status VARCHAR(50) DEFAULT 'pending' CHECK (status IN ('pending', 'in_progress', 'completed', 'failed', 'cancelled')),
    priority INTEGER DEFAULT 3 CHECK (priority BETWEEN 1 AND 5),
    due_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    result JSONB,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    -- 任务编号 (tenant_id 范围内唯一)
    CONSTRAINT uk_tasks_number_tenant UNIQUE (tenant_id, task_number)
);

-- 添加 task_number 字段
ALTER TABLE tasks ADD COLUMN task_number SERIAL;

-- 索引
CREATE INDEX idx_tasks_tenant_id ON tasks(tenant_id);
CREATE INDEX idx_tasks_yoo_id ON tasks(yoo_id);
CREATE INDEX idx_tasks_user_id ON tasks(user_id);
CREATE INDEX idx_tasks_status ON tasks(tenant_id, status);
CREATE INDEX idx_tasks_due_at ON tasks(due_at) WHERE status IN ('pending', 'in_progress');
CREATE INDEX idx_tasks_created_at ON tasks(tenant_id, created_at DESC);

-- 外键约束
ALTER TABLE tasks
    ADD CONSTRAINT fk_tasks_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id);
ALTER TABLE tasks
    ADD CONSTRAINT fk_tasks_yoo FOREIGN KEY (yoo_id) REFERENCES yooos(id);
ALTER TABLE tasks
    ADD CONSTRAINT fk_tasks_user FOREIGN KEY (user_id) REFERENCES users(id);
```

#### 3.2.5 interbot_messages (协作消息表)

```sql
-- 协作消息表（Yooos 之间通信）
CREATE TABLE interbot_messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    from_yoo_id UUID NOT NULL REFERENCES yooos(id) ON DELETE CASCADE,
    to_yoo_id UUID NOT NULL REFERENCES yooos(id) ON DELETE CASCADE,
    topic VARCHAR(100) NOT NULL,
    message_type VARCHAR(50) NOT NULL,
    payload JSONB NOT NULL,
    status VARCHAR(50) DEFAULT 'queued' CHECK (status IN ('queued', 'delivering', 'delivered', 'failed')),
    trace_id VARCHAR(100),
    delivered_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),

    -- 消息编号
    CONSTRAINT uk_messages_number UNIQUE (tenant_id, message_number)
);

ALTER TABLE interbot_messages ADD COLUMN message_number SERIAL;

-- 索引
CREATE INDEX idx_messages_tenant ON interbot_messages(tenant_id);
CREATE INDEX idx_messages_from_yoo ON interbot_messages(from_yoo_id);
CREATE INDEX idx_messages_to_yoo ON interbot_messages(to_yoo_id);
CREATE INDEX idx_messages_status ON interbot_messages(status);
CREATE INDEX idx_messages_topic ON interbot_messages(topic);
CREATE INDEX idx_messages_created_at ON interbot_messages(created_at DESC);
```

#### 3.2.6 skills (技能表)

```sql
-- 技能表
CREATE TABLE skills (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    yoo_id UUID NOT NULL REFERENCES yooos(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    category VARCHAR(100),
    config JSONB DEFAULT '{}',
    is_enabled BOOLEAN DEFAULT TRUE,
    usage_count INTEGER DEFAULT 0,
    last_used_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    CONSTRAINT uk_skills_name_tenant UNIQUE (name, tenant_id)
);

-- 索引
CREATE INDEX idx_skills_tenant ON skills(tenant_id);
CREATE INDEX idx_skills_yoo ON skills(yoo_id);
CREATE INDEX idx_skills_category ON skills(category);
CREATE INDEX idx_skills_enabled ON skills(is_enabled) WHERE is_enabled = TRUE;
```

#### 3.2.7 scheduled_tasks (定时任务表)

```sql
-- 定时任务表
CREATE TABLE scheduled_tasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    yoo_id UUID NOT NULL REFERENCES yooos(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    cron_expression VARCHAR(100) NOT NULL,
    timezone VARCHAR(50) DEFAULT 'UTC',
    payload JSONB DEFAULT '{}',
    is_enabled BOOLEAN DEFAULT TRUE,
    last_run_at TIMESTAMPTZ,
    last_status VARCHAR(50),
    last_error TEXT,
    next_run_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 索引
CREATE INDEX idx_scheduled_tenant ON scheduled_tasks(tenant_id);
CREATE INDEX idx_scheduled_yoo ON scheduled_tasks(yoo_id);
CREATE INDEX idx_scheduled_enabled ON scheduled_tasks(is_enabled) WHERE is_enabled = TRUE;
CREATE INDEX idx_scheduled_next_run ON scheduled_tasks(next_run_at) WHERE is_enabled = TRUE;
```

### 3.3 公共字段

所有业务表应包含以下公共字段：

| 字段 | 类型 | 说明 |
|------|------|------|
| id | UUID | 主键 |
| tenant_id | UUID | 租户 ID |
| created_at | TIMESTAMPTZ | 创建时间 |
| updated_at | TIMESTAMPTZ | 更新时间 |
| created_by | UUID | 创建者（可选） |
| is_deleted | BOOLEAN | 软删除标记（可选） |

### 3.4 审计表

```sql
-- 审计日志表
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    entity_type VARCHAR(100) NOT NULL,
    entity_id UUID NOT NULL,
    action VARCHAR(50) NOT NULL,
    old_value JSONB,
    new_value JSONB,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 索引
CREATE INDEX idx_audit_tenant ON audit_logs(tenant_id);
CREATE INDEX idx_audit_entity ON audit_logs(entity_type, entity_id);
CREATE INDEX idx_audit_user ON audit_logs(user_id);
CREATE INDEX idx_audit_created_at ON audit_logs(created_at DESC);

-- 清理策略
ALTER TABLE audit_logs SET (
    autovacuum_enabled = TRUE,
    autovacuum_vacuum_scale_factor = 0.1,
    autovacuum_vacuum_delete_scale_factor = 0.1
);

-- 自动清理 90 天前的日志
CREATE POLICY cleanup_audit_logs ON audit_logs
    FOR DELETE
    USING (created_at < NOW() - INTERVAL '90 days');
```

---

## 4. 数据访问模式

### 4.1 基础查询模板

```python
from typing import Optional
from sqlalchemy import select, update, delete
from sqlalchemy.ext.asyncio import AsyncSession

class YooRepository:
    async def get_by_id(
        self,
        db: AsyncSession,
        yoo_id: UUID,
        tenant_id: UUID
    ) -> Optional[Yoo]:
        """根据 ID 获取 Yoo（带租户验证）"""
        query = select(Yoo).where(
            Yoo.id == yoo_id,
            Yoo.tenant_id == tenant_id,
            Yoo.is_deleted == False
        )
        result = await db.execute(query)
        return result.scalar_one_or_none()

    async def list_by_tenant(
        self,
        db: AsyncSession,
        tenant_id: UUID,
        skip: int = 0,
        limit: int = 100,
        status: Optional[str] = None
    ) -> List[Yoo]:
        """列出租户的所有 Yoo"""
        query = select(Yoo).where(
            Yoo.tenant_id == tenant_id,
            Yoo.is_deleted == False
        )
        if status:
            query = query.where(Yoo.status == status)
        query = query.offset(skip).limit(limit).order_by(Yoo.created_at.desc())
        result = await db.execute(query)
        return result.scalars().all()

    async def update_status(
        self,
        db: AsyncSession,
        yoo_id: UUID,
        tenant_id: UUID,
        status: str
    ) -> bool:
        """更新 Yoo 状态（带租户验证）"""
        query = update(Yoo).where(
            Yoo.id == yoo_id,
            Yoo.tenant_id == tenant_id
        ).values(
            status=status,
            updated_at=func.now()
        )
        result = await db.execute(query)
        return result.rowcount > 0
```

### 4.2 软删除模式

```python
class SoftDeleteRepository:
    async def soft_delete(
        self,
        db: AsyncSession,
        model,
        id: UUID,
        tenant_id: UUID,
        user_id: UUID
    ) -> bool:
        """软删除记录"""
        from sqlalchemy import update

        # 更新记录
        query = update(model).where(
            model.id == id,
            model.tenant_id == tenant_id
        ).values(
            is_deleted=True,
            deleted_by=user_id,
            deleted_at=func.now(),
            updated_at=func.now()
        )
        result = await db.execute(query)

        # 记录审计日志
        await self.log_action(
            db,
            tenant_id=tenant_id,
            user_id=user_id,
            entity_type=model.__name__,
            entity_id=id,
            action="DELETE",
            new_value={"is_deleted": True}
        )

        return result.rowcount > 0

    async def restore(
        self,
        db: AsyncSession,
        model,
        id: UUID,
        tenant_id: UUID,
        user_id: UUID
    ) -> bool:
        """恢复软删除的记录"""
        from sqlalchemy import update

        query = update(model).where(
            model.id == id,
            model.tenant_id == tenant_id,
            model.is_deleted == True
        ).values(
            is_deleted=False,
            deleted_by=None,
            deleted_at=None,
            updated_at=func.now()
        )
        result = await db.execute(query)
        return result.rowcount > 0
```

### 4.3 多租户查询示例

```python
from sqlalchemy.orm import joinedload
from typing import List

class TaskService:
    async def get_tasks_with_details(
        self,
        db: AsyncSession,
        tenant_id: UUID,
        user_id: UUID,
        yoo_id: Optional[UUID] = None
    ) -> List[Task]:
        """获取用户的任务列表（带关联数据）"""
        query = select(Task).options(
            joinedload(Task.yoo),
            joinedload(Task.creator)
        ).where(
            Task.tenant_id == tenant_id,
            Task.user_id == user_id,
            Task.is_deleted == False
        )

        if yoo_id:
            query = query.where(Task.yoo_id == yoo_id)

        query = query.order_by(Task.created_at.desc())

        result = await db.execute(query)
        return result.unique().scalars().all()

    async def batch_update_status(
        self,
        db: AsyncSession,
        tenant_id: UUID,
        task_ids: List[UUID],
        status: str,
        user_id: UUID
    ) -> int:
        """批量更新任务状态"""
        from sqlalchemy import update

        query = update(Task).where(
            Task.id.in_(task_ids),
            Task.tenant_id == tenant_id,
            Task.is_deleted == False
        ).values(
            status=status,
            updated_at=func.now()
        )

        result = await db.execute(query)

        # 记录审计日志
        await self.log_action(
            db,
            tenant_id=tenant_id,
            user_id=user_id,
            entity_type="Task",
            entity_id=task_ids[0] if task_ids else None,
            action="BATCH_UPDATE",
            new_value={"status": status, "count": len(task_ids)}
        )

        return result.rowcount
```

---

## 5. 数据隔离策略

### 5.1 应用层隔离

```python
from fastapi import Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession

async def get_tenant_session(
    request: Request,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> AsyncSession:
    """验证用户租户并返回数据库会话"""
    # 租户信息已通过 JWT 验证
    request.state.tenant_id = current_user.tenant_id
    request.state.user_id = current_user.id
    return db

class TenantRepository:
    @require_tenant
    async def get_data(self, db: AsyncSession, tenant_id: UUID, data_id: UUID):
        """获取数据（自动应用租户过滤）"""
        query = select(Data).where(
            Data.id == data_id,
            Data.tenant_id == tenant_id,
            Data.is_deleted == False
        )
        result = await db.execute(query)
        return result.scalar_one_or_none()
```

### 5.2 Row Level Security (RLS)

PostgreSQL 的行级安全策略：

```sql
-- 启用 RLS
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE yooos ENABLE ROW LEVEL SECURITY;
ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;

-- 创建策略
CREATE POLICY tenant_isolation_policy ON users
    FOR ALL
    USING (tenant_id = current_setting('app.current_tenant_id')::UUID)
    WITH CHECK (tenant_id = current_setting('app.current_tenant_id')::UUID);

CREATE POLICY tenant_isolation_policy ON yooos
    FOR ALL
    USING (tenant_id = current_setting('app.current_tenant_id')::UUID)
    WITH CHECK (tenant_id = current_setting('app.current_tenant_id')::UUID);

CREATE POLICY tenant_isolation_policy ON tasks
    FOR ALL
    USING (tenant_id = current_setting('app.current_tenant_id')::UUID)
    WITH CHECK (tenant_id = current_setting('app.current_tenant_id')::UUID);

-- 在应用层设置租户上下文
CREATE OR REPLACE FUNCTION set_tenant_context()
RETURNS TRIGGER AS $$
BEGIN
    EXECUTE format('SET app.current_tenant_id = %L', NEW.tenant_id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 在事务开始时设置租户
CREATE OR REPLACE FUNCTION set_tenant_from_session()
RETURNS TRIGGER AS $$
BEGIN
    PERFORM set_config('app.current_tenant_id', NEW.tenant_id::text, true);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### 5.3 数据访问审计

```python
import logging
from contextvars import ContextVar

logger = logging.getLogger(__name__)
audit_logger = logging.getLogger("audit")

# 上下文变量
current_tenant_id: ContextVar[UUID] = ContextVar("current_tenant_id")
current_user_id: ContextVar[UUID] = ContextVar("current_user_id")

class AuditMiddleware:
    async def dispatch(self, request: Request, call_next):
        # 获取租户和用户信息
        tenant_id = request.state.get("tenant_id")
        user_id = request.state.get("user_id")

        # 设置上下文
        if tenant_id:
            current_tenant_id.set(tenant_id)
        if user_id:
            current_user_id.set(user_id)

        # 处理请求
        response = await call_next(request)

        # 记录访问日志
        audit_logger.info({
            "tenant_id": str(tenant_id) if tenant_id else None,
            "user_id": str(user_id) if user_id else None,
            "method": request.method,
            "path": request.url.path,
            "status_code": response.status_code,
        })

        return response
```

---

## 6. 性能优化

### 6.1 索引策略

```sql
-- 复合索引设计
CREATE INDEX idx_tasks_tenant_status_priority
    ON tasks(tenant_id, status, priority DESC)
    WHERE is_deleted = FALSE;

-- 部分索引（只索引活跃数据）
CREATE INDEX idx_yooos_running
    ON yooos(last_heartbeat_at DESC)
    WHERE status = 'running';

-- 覆盖索引（减少回表查询）
CREATE INDEX idx_tasks_list_covering
    ON tasks(tenant_id, status, created_at DESC)
    INCLUDE (title, description, priority);
```

### 6.2 分区策略

```sql
-- 按月分区 tasks 表
CREATE TABLE tasks (
    LIKE tasks_original INCLUDING ALL
) PARTITION BY RANGE (created_at);

-- 创建月度分区
CREATE TABLE tasks_2026_01 PARTITION OF tasks
    FOR VALUES FROM ('2026-01-01') TO ('2026-02-01');

CREATE TABLE tasks_2026_02 PARTITION OF tasks
    FOR VALUES FROM ('2026-02-01') TO ('2026-03-01');

-- 添加更多分区...
```

### 6.3 物化视图（报表）

```sql
-- 租户统计物化视图
CREATE MATERIALIZED VIEW tenant_stats AS
SELECT
    tenant_id,
    COUNT(*) FILTER (WHERE is_deleted = FALSE) as total_tasks,
    COUNT(*) FILTER (WHERE status = 'completed') as completed_tasks,
    COUNT(DISTINCT yoo_id) as total_yooos,
    COUNT(DISTINCT user_id) as total_users,
    MIN(created_at) as first_activity,
    MAX(created_at) as last_activity
FROM tasks
GROUP BY tenant_id;

CREATE UNIQUE INDEX idx_tenant_stats_tenant ON tenant_stats(tenant_id);

-- 刷新视图（定时任务）
CREATE OR REPLACE FUNCTION refresh_tenant_stats()
RETURNS VOID AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY tenant_stats;
END;
$$ LANGUAGE plpgsql;
```

---

## 7. 备份和恢复

### 7.1 备份策略

```sql
-- 逻辑备份（pg_dump）
pg_dump -h localhost -U postgres -d yoyoo \
    --no-owner --no-privileges \
    --table="tenants" --table="users" \
    --table="yooos" --table="tasks" \
    > yoyoo_backup.sql

-- 增量备份（使用 pglogical 或 wal-g）
-- 定时任务：每天凌晨 3 点全量备份
0 3 * * * pg_dump -Fc yoyoo | gzip > /backup/yoo_$(date +\%Y\%m\%d).sql.gz
```

### 7.2 恢复脚本

```bash
#!/bin/bash
# restore.sh - 恢复数据

BACKUP_FILE=$1
TENANT_ID=$2

# 恢复前检查
echo "恢复前检查..."
psql -c "SELECT 1" || exit 1

# 恢复数据
echo "恢复数据..."
pg_restore -d yoyoo --clean --if-exists $BACKUP_FILE

# 验证
echo "验证数据..."
psql -d yoyoo -c "SELECT COUNT(*) FROM tenants WHERE id = '$TENANT_ID'"
```

---

## 8. 总结

### 8.1 核心表清单

| 表名 | 说明 | 核心字段 |
|------|------|----------|
| tenants | 租户 | id, name, slug, plan |
| users | 用户 | id, tenant_id, email, name |
| yooos | Yooos 实例 | id, tenant_id, user_id, name, status |
| tasks | 任务 | id, tenant_id, yoo_id, title, status |
| interbot_messages | 协作消息 | id, tenant_id, from_yoo_id, to_yoo_id |
| skills | 技能 | id, tenant_id, yoo_id, name |
| scheduled_tasks | 定时任务 | id, tenant_id, yoo_id, cron_expression |
| audit_logs | 审计日志 | id, tenant_id, entity_type, action |

### 8.2 关键设计决策

| 决策 | 选择 | 理由 |
|------|------|------|
| 租户隔离模式 | 共享数据库 + tenant_id | 成本、管理复杂度平衡 |
| 主键类型 | UUID | 分布式环境友好 |
| 删除方式 | 软删除 (is_deleted) | 数据可恢复、审计保留 |
| 外键策略 | CASCADE 删除 | 简化业务逻辑 |
| 索引策略 | tenant_id 前缀 | 高效多租户查询 |

### 8.3 下一步

1. 实现数据库迁移 (Alembic)
2. 添加数据验证层
3. 实现缓存策略 (Redis)
4. 配置监控和告警

---

> **笔记版本**: 1.0
> **创建人**: Yoyoo
> **最后更新**: 2026-01-31
> **状态**: 多租户数据库架构学习完成
