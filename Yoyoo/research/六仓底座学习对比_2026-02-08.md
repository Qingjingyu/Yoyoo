# 六仓底座学习对比（2026-02-08）

## 1. 本轮目标
不是比“谁功能多”，而是比“谁更适合作为 Yoyoo Brain 的长期底座”：
- 稳定可运维
- 可控可改造
- 能承载记忆/规划/验收闭环
- 后续可持续迭代

本次已完成：
- 六仓源码全部下载到 `Yoyoo project/base-repos/`
- 代码结构与 README/文档快速深读
- GitHub 活跃度快照抓取（2026-02-08）

## 2. 仓库快照（2026-02-08）
| 项目 | 本地文件数 | 本地体积 | GitHub Stars | 最近推送时间(UTC) |
|---|---:|---:|---:|---|
| openclaw/openclaw | 4771 | 79M | 175299 | 2026-02-08T12:31:17Z |
| HKUDS/nanobot | 80 | 64M | 12935 | 2026-02-08T10:10:24Z |
| openakita/openakita | 366 | 25M | 42 | 2026-02-08T12:31:33Z |
| openkursar/hello-halo | 407 | 14M | 446 | 2026-02-07T12:45:01Z |
| NevaMind-AI/memU | 219 | 27M | 8372 | 2026-02-06T00:55:10Z |
| iOfficeAI/AionUi | 847 | 617M | 12900 | 2026-02-08T10:20:24Z |

## 3. 逐项判断（围绕 Yoyoo Brain）

### 3.1 OpenClaw
- 定位：强工程化执行内核（多通道、会话路由、工具系统、网关协议、插件扩展）。
- 优势：运行稳定、通道与执行链路成熟、可运维能力强、生态大。
- 风险：代码体量大，直接改“脑层逻辑”会复杂。
- 结论：最适合做“执行底座/系统主干”。

### 3.2 Nanobot
- 定位：超轻量 Agent 框架（Python，改造快，学习成本低）。
- 优势：代码短小、策略实验和原型验证非常高效。
- 风险：生产级治理、复杂路由、长周期稳定性弱于 OpenClaw。
- 结论：最适合做“策略实验场”，不建议单独扛生产主干。

### 3.3 OpenAkita
- 定位：强调“自进化/记忆/计划”的 Python 助手框架。
- 优势：概念和模块对 Yoyoo 目标贴合（brain、memory、scheduler、evolution）。
- 风险：生态与成熟度明显弱于 OpenClaw。
- 结论：适合借鉴“脑层设计思想”，不建议做唯一生产底座。

### 3.4 memU
- 定位：主动记忆框架（长期记忆、意图捕获、低 token 成本）。
- 优势：对 Yoyoo 的“记忆中枢”价值高，可作为记忆子系统参考或组件来源。
- 风险：它是“记忆框架”，不是全栈 Agent 主系统。
- 结论：适合作为 Yoyoo Brain 的“记忆增强模块”。

### 3.5 hello-halo
- 定位：图形化 Agent 客户端（Electron），偏交互层。
- 优势：UI 体验与易用性强。
- 风险：核心价值在前端壳层，不在 Brain 内核。
- 结论：可借鉴交互，不适合做大脑底座。

### 3.6 AionUi
- 定位：多 CLI Agent 的统一图形工作台（Electron + 多模型接入）。
- 优势：整合能力强、远程接入与多助手展示强。
- 风险：仍偏“工作台/控制台”，不是 Brain 核心。
- 结论：适合作为未来控制面，不适合做 Brain 内核。

## 4. 最终建议（当前阶段）

### 主线建议
- **底座主干：OpenClaw**
- **策略实验：Nanobot**
- **记忆增强：memU（或其设计）**

### 为什么不是单选 Nanobot / OpenAkita
- 你要的是长期稳定可进化产品，而不是仅快速 demo。
- OpenClaw 在通道、执行、运维上明显更稳；Nanobot/OpenAkita 更适合提供“脑层思路和快速实验速度”。

## 5. 对 Yoyoo Brain 的落地含义
- Brain 不直接做底层执行细节；Brain 负责：意图理解、任务拆解、验收与记忆。
- OpenClaw 负责执行与通道。
- memU 负责长期记忆增强。

一句话：
**Yoyoo = 一个对外身份 + Brain 决策层 + OpenClaw 执行层 + memU 记忆增强。**

## 6. 下一步（进入开发前）
1. 固定“单一对外身份”策略（避免多机器人同群并发讲话）。
2. 定 Brain 的最小接口：`plan_task` / `dispatch` / `verify` / `memorize`。
3. 先做 P0 闭环：一条消息 -> 任务拆解 -> OpenClaw 执行 -> 证据回收 -> 记忆入库。

